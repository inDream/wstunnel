// Generated by CoffeeScript 1.8.0
(function() {
  var ClientConn, WsStream, createWsClient, etagHeader, log, net, url, wst_client,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  net = require("net");

  WsStream = require("./WsStream");

  url = require('url');

  log = require("lawg");

  ClientConn = require("./httptunnel/ClientConn");

  etagHeader = require("./etagHeader");

  createWsClient = function() {
    return new (require('websocket').client)();
  };

  module.exports = wst_client = (function(_super) {
    __extends(wst_client, _super);


    /*
    emit Events:
    'tunnel' (WsStream|ClientConn) when a tunnel is established
    'connectFailed' (err) when ws connection failed
    'connectHttpFailed' (err) when http tunnel connection failed
     */

    function wst_client() {
      this.tcpServer = net.createServer();
    }

    wst_client.prototype.verbose = function() {
      this.on('tunnel', (function(_this) {
        return function(ws, sock) {
          if (ws instanceof WsStream) {
            log('Websocket tunnel established');
          } else {
            log('Http tunnel established');
          }
          return sock.on('close', function() {
            return log('Tunnel closed');
          });
        };
      })(this));
      this.on('connectHttpFailed', (function(_this) {
        return function(error) {
          return log('HTTP connect error: ' + error.toString());
        };
      })(this));
      return this.on('connectFailed', (function(_this) {
        return function(error) {
          return log('WS connect error: ' + error.toString());
        };
      })(this));
    };

    wst_client.prototype.setHttpOnly = function(httpOnly) {
      this.httpOnly = httpOnly;
    };

    wst_client.prototype.start = function(localAddr, wsHostUrl, remoteAddr, optionalHeaders, cb) {
      var localHost, localPort, _ref;
      this.wsHostUrl = wsHostUrl;
      if (typeof optionalHeaders === 'function') {
        cb = optionalHeaders;
        optionalHeaders = {};
      }
      if (typeof localAddr === 'number') {
        localPort = localAddr;
      } else {
        _ref = localAddr.split(':'), localHost = _ref[0], localPort = _ref[1];
        if (/^\d+$/.test(localHost)) {
          localPort = localHost;
          localHost = null;
        }
        localPort = parseInt(localPort);
      }
      if (localHost == null) {
        localHost = '127.0.0.1';
      }
      this.tcpServer.listen(localPort, localHost, cb);
      return this.tcpServer.on("connection", (function(_this) {
        return function(tcpConn) {
          var httpConnect, httpConnectCb, wsConnect;
          wsConnect = function(cb) {
            var urlo, wsClient, wsurl;
            if (remoteAddr) {
              wsurl = "" + _this.wsHostUrl + "/?dst=" + remoteAddr;
            } else {
              wsurl = "" + _this.wsHostUrl;
            }
            wsClient = createWsClient();
            urlo = url.parse(wsurl);
            if (urlo.auth) {
              optionalHeaders.Authorization = 'Basic ' + (new Buffer(urlo.auth)).toString('base64');
            }
            wsClient.connect(wsurl, 'tunnel-protocol', remoteAddr, optionalHeaders);
            wsClient.on('connectFailed', function(error) {
              return cb(error);
            });
            return wsClient.on('connect', function(wsConn) {
              var wsStream;
              wsStream = new WsStream(wsConn);
              return cb(null, wsStream);
            });
          };
          httpConnect = function(cb) {
            var httpConn, tunurl;
            tunurl = _this.wsHostUrl.replace(/^ws/, 'http');
            if (remoteAddr) {
              tunurl += "?dst=" + remoteAddr;
            }
            httpConn = new ClientConn(tunurl);
            return httpConn.connect(optionalHeaders, function(err) {
              if (err) {
                return cb(err);
              } else {
                return cb(null, httpConn);
              }
            });
          };
          httpConnectCb = function(error, httpConn) {
            if (error) {
              _this.emit('connectHttpFailed', error);
              return tcpConn.end();
            } else {
              require("./bindStream")(httpConn, tcpConn);
              return _this.emit('tunnel', httpConn, tcpConn);
            }
          };
          if (_this.httpOnly) {
            return httpConnect(httpConnectCb);
          } else {
            return wsConnect(function(error, wsStream) {
              if (!error) {
                require("./bindStream")(wsStream, tcpConn);
                return _this.emit('tunnel', wsStream, tcpConn);
              } else {
                _this.emit('connectFailed', error);
                return httpConnect(httpConnectCb);
              }
            });
          }
        };
      })(this));
    };

    return wst_client;

  })(require('events').EventEmitter);

}).call(this);

//# sourceMappingURL=WstClient.js.map
