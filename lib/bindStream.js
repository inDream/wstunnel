// Generated by CoffeeScript 1.8.0
(function() {
  var debug, future, log, name, _, _n;

  _ = require("underscore");

  log = require("lawg");

  future = require("phuture");

  debug = require("./debug");

  _n = 0;

  name = function(stream) {
    return stream._sig || "tcp";
  };

  module.exports = function(ws, tcp) {
    var SpeedMeter, autoPipe, dlog, llog, manualPipe, n, stop;
    n = _n++;
    llog = function(stream, msg) {
      return log("" + n + " " + (name(stream)) + " " + msg);
    };
    if (debug.isDebug) {
      dlog = llog;
    } else {
      dlog = function() {};
    }
    stop = function() {
      if (!this._stop) {
        dlog(this, 'stop');
        this._stop = true;
        return this.end();
      }
    };
    ws.stop = stop;
    tcp.stop = stop;
    ws.on('error', function(err) {
      llog(ws, err);
      ws.stop();
      return tcp.stop();
    });
    tcp.on('error', function(err) {
      llog(tcp, err);
      tcp.stop();
      return ws.stop();
    });
    manualPipe = function() {
      ws.on('data', function(data) {
        if (!tcp._stop) {
          console.log(data);
          console.log(data.toString('utf8'));
          return tcp.write(data);
        }
      });
      tcp.on('data', function(data) {
        if (!ws._stop) {
          console.log(data);
          console.log(data.toString('utf8'));
          return ws.write(data);
        }
      });
      ws.on('finish', function() {
        dlog(ws, 'finish');
        return tcp.stop();
      });
      ws.on('end', function() {
        dlog(ws, 'end');
        return tcp.stop();
      });
      ws.on('close', function() {
        dlog(ws, 'close');
        return tcp.stop();
      });
      tcp.on('finish', function() {
        dlog(tcp, 'finish');
        return ws.stop();
      });
      tcp.on('end', function() {
        dlog(tcp, 'end');
        return ws.stop();
      });
      return tcp.on('close', function() {
        dlog(tcp, 'close');
        return ws.stop();
      });
    };
    autoPipe = function() {
      var end;
      ws.on('close', function() {
        dlog(ws, 'close');
        return tcp.stop();
      });
      tcp.on('close', function() {
        dlog(tcp, 'close');
        return ws.stop();
      });
      end = true;
      return ws.pipe(tcp, {
        end: end
      }).pipe(ws, {
        end: end
      });
    };
    // autoPipe();
    manualPipe();
    SpeedMeter = (function() {
      function SpeedMeter(msg) {
        this.msg = msg;
        this.n = 0;
        this.timer = future.interval(1000, (function(_this) {
          return function() {
            if (_this.n > 0) {
              log("" + _this.msg + " " + (_this.n / 1000) + "k/s");
              return _this.n = 0;
            }
          };
        })(this));
      }

      SpeedMeter.prototype.attach = function(readStream) {
        readStream.on('data', (function(_this) {
          return function(d) {
            return _this.n += d.length;
          };
        })(this));
        return readStream.on('end', (function(_this) {
          return function() {
            return _this.timer.cancel();
          };
        })(this));
      };

      return SpeedMeter;

    })();
    if (debug.isDebug) {
      (new SpeedMeter(name(ws))).attach(ws);
      return (new SpeedMeter(name(tcp))).attach(tcp);
    }
  };

}).call(this);

//# sourceMappingURL=bindStream.js.map
